# 五子棋AI项目

基于蒙特卡洛树搜索(MCTS)和神经网络的五子棋AI系统，采用AlphaZero风格的自我对弈训练。

## 项目特点

- 🎯 **纯Python实现**：易于理解和修改
- 🧠 **MCTS + 神经网络**：结合传统搜索和深度学习
- 🔄 **自我对弈训练**：无需人工标注数据
- 🎮 **完整对战系统**：支持人机对战、AI对战
- ⚡ **性能优化**：搜索时间控制在1-3秒
- 📊 **训练监控**：实时显示训练进度和性能

## 项目结构

```
MachineLearning/
├── board.py          # 五子棋棋盘逻辑
├── mcts.py           # 蒙特卡洛树搜索算法
├── net.py            # 神经网络架构
├── game.py           # 游戏引擎和AI玩家
├── train.py          # 训练框架
├── play.py           # 对战接口
├── requirements.txt  # 项目依赖
├── quick_test.py     # 快速验证脚本
└── README.md         # 项目说明
```

## 快速开始

### 1. 环境准备

```bash
# 安装依赖
pip install -r requirements.txt

# 验证安装
python quick_test.py
```

### 2. 基础测试

```bash
# 测试MCTS基础功能
python mcts.py

# 测试神经网络
python net.py

# 测试游戏引擎
python game.py
```

### 3. 开始对战

```bash
# 启动交互式对战界面
python play.py

# 或者直接命令行模式
python play.py --mode play
```

### 4. 训练模型

```bash
# 交互式训练
python play.py
# 选择菜单中的 "3. 训练模型"

# 或者命令行训练
python play.py --mode train --iterations 50 --games 20
```

## 核心算法

### MCTS (蒙特卡洛树搜索)

实现了标准的MCTS四个阶段：

1. **选择 (Selection)**: 使用UCB1公式选择最有前途的节点
2. **扩展 (Expansion)**: 添加新的子节点
3. **模拟 (Simulation)**: 随机模拟到游戏结束
4. **反向传播 (Backpropagation)**: 更新路径上所有节点的统计信息

```python
# UCB1公式
UCB1 = wins/visits + c * sqrt(ln(parent_visits) / visits)
```

### 神经网络架构

- **输入**: 3通道棋盘状态 (当前玩家棋子、对手棋子、当前玩家标识)
- **主干**: 残差卷积网络
- **输出**: 
  - 策略头：每个位置的移动概率
  - 价值头：当前局面的胜率评估

### 训练流程

1. **自我对弈**: AI与自己对战生成训练数据
2. **数据收集**: 记录每个局面的状态、策略、结果
3. **网络训练**: 使用收集的数据训练神经网络
4. **模型评估**: 与之前版本对战测试性能
5. **迭代优化**: 重复上述过程

## 使用指南

### 人机对战

1. 运行 `python play.py`
2. 选择 "1. 人机对战"
3. 选择AI强度 (简单/普通/困难/专家)
4. 选择是否使用训练好的模型
5. 选择先后手
6. 开始游戏！

输入格式：
- `4,4` 或 `4 4` - 在第4行第4列落子
- `quit` 或 `q` - 退出游戏

### AI对战

观看两个AI之间的对战，可以：
- 测试不同模型的性能
- 比较不同强度设置
- 进行批量对战统计

### 模型训练

训练参数说明：
- **棋盘大小**: 推荐9x9 (计算效率) 或 15x15 (标准五子棋)
- **网络通道数**: 32-128，影响模型容量
- **训练迭代**: 每轮包含自我对弈+网络训练
- **自我对弈局数**: 每轮生成的训练数据量
- **训练轮数**: 每轮对网络的训练次数

## 性能调优

### MCTS参数

- **时间限制**: 控制每步思考时间
- **最大迭代**: 限制搜索深度
- **UCB1常数**: 平衡探索与利用

### 训练参数

- **学习率**: 0.001-0.01
- **批大小**: 16-64
- **数据集大小**: 10000-50000条

## 项目进度

### ✅ 已完成 (第1天)

- [x] 基础MCTS实现 (纯随机模拟版本)
- [x] 搜索功能测试 (选择、扩展、模拟、反向传播)
- [x] UCB1公式调试
- [x] 性能优化 (搜索时间1-3秒)

### 🚧 开发中 (第2-7天)

- [x] 神经网络架构 (`net.py`)
- [x] 游戏引擎 (`game.py`)
- [x] 训练框架 (`train.py`)
- [x] 对战接口 (`play.py`)
- [ ] 整合测试
- [ ] 性能优化
- [ ] 文档完善

## 技术细节

### 棋盘表示

```python
# 9x9棋盘，numpy数组
# 0: 空位
# 1: 黑棋 (先手)
# -1: 白棋 (后手)
board = np.zeros((9, 9), dtype=np.int8)
```

### 胜负判断

检查水平、垂直、对角线方向是否有5个连续的同色棋子。

### 数据格式

训练数据格式：
```python
{
    'board_state': torch.FloatTensor,  # (3, 9, 9)
    'policy': torch.FloatTensor,       # (81,)
    'value': torch.FloatTensor         # (1,)
}
```

## 常见问题

### Q: 为什么选择9x9而不是15x15？
A: 9x9棋盘计算复杂度更低，适合快速实验和学习。可以轻松修改为15x15。

### Q: 训练需要多长时间？
A: 在普通CPU上，基础训练约需要几小时到一天。使用GPU可以显著加速。

### Q: 如何提高AI强度？
A: 
1. 增加MCTS搜索时间和迭代次数
2. 使用更大的神经网络
3. 进行更多轮训练
4. 增加训练数据量

### Q: 可以与其他五子棋程序对战吗？
A: 目前是独立系统，但可以通过修改接口支持标准协议。

## 贡献指南

欢迎提交Issue和Pull Request！

1. Fork项目
2. 创建特性分支
3. 提交更改
4. 推送到分支
5. 创建Pull Request

## 许可证

MIT License - 详见LICENSE文件

## 致谢

- AlphaGo/AlphaZero论文提供了算法灵感
- 五子棋社区提供了游戏规则参考
- 开源社区提供了技术支持

---

**开始你的五子棋AI之旅吧！** 🎮🤖